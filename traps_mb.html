<!DOCTYPE html>
<meta name="viewport" content="user-scalable=yes, width=device-width">
<style type="text/css">
	body{font-family:Verdana, sans-serif;line-height:1.5em;font-size:1.2em;color:#111;background:#fff;width:auto;max-width:33em;margin:auto;padding:1em}
	a, #reload{color:#38f;text-decoration:none; cursor:pointer}
	h1,h2,h3{font-weight:400;font-family:Helvetica, Ariel, sans-serif;color:#222}
	h1{font-size:1.5em;line-height:1.2em;margin-top:.5em;margin-bottom:.5em}
	h2,h3{font-size:1.2em;line-height:1.2em;margin:0;padding:0}
	li{margin-bottom:.6em}
</style>

<title>Random Trap Generator</title>
<h1>Random Trap Generator</h1>
<p>by Michael E. Shea

<p>This page randomly generates a list of 100 trap sets. Each trap set includes two traps with two elemental effects tied to a single trigger. GMs can use this page directly or <a href="">download a PDF</a> of 100 random trap sets to use during their game.

<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"></script>

<script type="text/javascript">
	
	// Create trap object with trigger, element, and attack lists
	var trap = {trigger:[""], element:[""], attack:[""]};

	trap.trigger = [
		"a child's toy",
		"a jeweled skull",
		"floor plates",
		"giant knockers",
		"beams of light",
		"golden angelic statue",
		"a crystal goblet on a pedestal",
		"mischievous ghosts",
		"the correct answer to an easy riddle",
		"a rough gemstone",
		"an old wooden chest",
		"an onyx demonic skull",
		"a forbidden scroll",
		"a jeweled pillar",
		"steep stairs",
		"a sacrificial bowl and dagger",
		"a jeweled crown on a skeleton's head",
		"delicate pots",
		"an ancient leatherbound tome",
		"tripwires",
		"a gilded sarcophagi",
		"delicate magic-detecting spheres",
		"a bound prisoner",
		"a weapon on an altar",
		"an idol on pedestal",
		"alternating floor tiles",
		"iron-bound chests",
		"tiny threads strung across the room",
		"glass orbs that vibrate with sound",
		"hidden magnets",
		"an ornate throne",
		"a hidden enemy",
		"hanging ropes",
	];

	trap.element = [
		"flaming",
		"icy",
		"electrical",
		"poisonous",
		"ethereal",
		"unholy",
		"necrotic",
		"diseased",
		"acidic",
		"dazzling",
		"infested",
		"moldy",
		"fungus-encrusted",
		"deafening",
		"fear-inducing",
		"confusion-inducing",
		"energy-draining",
		"entangling",
		"fatiguing",
		"invisible",
		"nauseating",
		"forceful",
		"panic-inducing",
		"silencing",
		"stunning",
		"ooze-covered",
		"gaseous",
		"negative energy",
		"shadowy",
		"radiant",
		"arcane",
		"psychic",
		"sleep-inducing",
		"sonic",
		"explosive",
		"blinding",
		"gravity reversing",
	];

	trap.attack = [
		"darts",
		"spears",
		"swinging spiked chains",
		"hammers",
		"swinging glaives",
		"spiked pits",
		"rocks",
		"javelins",
		"animated statues",
		"pillars",
		"ballistae",
		"barbed nets",
		"bolas",
		"catapults",
		"bear traps",
		"caltrops",
		"crushing walls",
		"floor tiles",
		"monster summoners",
		"alarms",
		"razor-wire",
		"skulls",
		"swinging axes",
		"snares",
		"cages",
		"crossbows",
		"swinging blades",
		"scythes",
		"metal disks",
		"beams",
		"glyphs",
		"spores",
	];

// Create a TrapGenerator object. We'll then add new functions to this object.
// MB: This is now a constructor to a new object type called TrapGenerator. Every "object" in java is basically a collection of key-value pairs
// 		so here I have created a new basically a new Object() called TrapGenerator and assigned the property Function = TrapGenerator(...).
// 		Now the this keyword refers back to the same new Object() and assigns them as new properties. 
//		Note they are all public this way, I could do var triggers to make it private and avoid using the prototype object which is better 
// 		See http://philogb.github.io/blog/2010/10/10/javascript-class-performance/ and http://jsperf.com/calling-public-methods-accessing-private-vars
//		I have done this in my traps_mb_v2.html file. Which is better, in terms of performance, if very dependent on the browser. FF no diff - Chrome proto (this) better
function TrapGenerator(trigger, element, attack) {
	this.trigger = trigger; 
	this.element = element; 
	this.attack = attack;
}

// Create a shuffle function for the TrapGenerator object. It takes in one of the lists and returns a shuffled version of that array.
// MB: Here I have made a change to illustrate another design pattern... I dropped the prototype
//		That makes this function static, that is since I don't access data specific to an instance of TrapGenerator, I don't need
// 		a new copy made for each object. Just one will surffice. 
//		Do you mean overall shuffle was called 14,000 times? I had it set to 3500 entries so it would have been called a lot. 
//		Two things to note here, 1) I am not shuffling your lists, just a list of numbers (see comments on generate_random_list)
// 								 2) by doing it on a list of numbers I and doing it in place I am saving a lot of memory.
//									 a) I am promised that an int won't be more than 8 bytes as opposed to a string that is 1 byte per letter
//									 b) I am not creating more lists than I need containing a lot of text
//		By calling it from array.length-1 and down we ensure we don't reshuffle anything shuffled. See http://bost.ocks.org/mike/shuffle/
TrapGenerator.shuffle = function(array) {
    for (var i = array.length-1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));

	 	temp = array[i];
	    array[i] = array[j];
	    array[j] = temp;
    }

    return array;
}

// This function takes in a
// MB: This function works some vodoo that takes a bit to follow. From the inside out this is what is happening... 
// 		See http://stackoverflow.com/questions/3746725/create-a-javascript-array-containing-1-n 
//		1) Array.apply(null, {length: in_length}) <-- calls the array constructor on null (i.e. new object) and assigns the property length = in_length 
//		2) Calling map on the array calls Number.call on each element with the argument Number which through magic (see the post) assigns the index of each element to the element
//		3) Now we have an array of [0,1,2,...N] and we shuffle it 
//		4) We repeat, using all elements first, until the total list length is as long as we need it to be. 
//		In theory the last number of list X and the first of X+1 could be the same but the chances are 1/(list length)^2 so ~0.08 % in this case, it is more work to check than trust
TrapGenerator.generate_random_list = function(in_length, out_length){
	var output_list = [];

	for(var i = 0; i < out_length/in_length; i++) 
		output_list = output_list.concat(TrapGenerator.shuffle(Array.apply(null, {length: in_length}).map(Number.call, Number)));

	return output_list;
}

//MB: Here I do fun stuff...
//		1) I generate my list of random numbers for each category 
//		2) Then I populate an output list using my psuedo random list at this point (b/c I pushed each set b4 repeating)
//			I check to make sure I don't pull the same element or attack twice, if so I just swap it 
TrapGenerator.prototype.generate = function(length){
	var output_list = [];
	var trigger_items = TrapGenerator.generate_random_list(this.trigger.length, length); 	
	var element_items = TrapGenerator.generate_random_list(this.element.length, 2 * length); 	
	var attack_items  = TrapGenerator.generate_random_list(this.attack.length,  2 * length);

	var i; 
	for(i = 0; i < length; i++){
		while(element_items[i] === element_items[2*i+1]) element_items[2*i+1] = element_items.splice(2*i-Math.random()*length, 1, element_items[2*i+1])[0];
		while(attack_items[i] === attack_items[2*i+1]) attack_items[2*i+1] = attack_items.splice(2*i-Math.random()*length, 1, attack_items[2*i+1])[0];

		output_list.push({
			trigger: this.trigger[trigger_items[i]],
			element_one: this.element[element_items[i]],
			element_two: this.element[element_items[2*i+1]],
			attack_one: this.attack[attack_items[i]],
			attack_two: this.attack[attack_items[2*i+1]]
		})
	}

	return output_list; 
}

//MB: After the list is generated, I just output it. I avoid the overhead you had of making an array that you then collapse and put into another array by forming the string directly
TrapGenerator.prototype.show = function(length, targetDiv, write_out){
	var raw_list = this.generate(length);
	var output_list = [];
    
    var i;
    for (i=0; i < length; i++) {
        output_list.push(raw_list[i].element_one.charAt(0).toUpperCase() + raw_list[i].element_one.slice(1) + " " + raw_list[i].attack_one + " and " + raw_list[i].element_two + " " + raw_list[i].attack_two + " triggered by " + raw_list[i].trigger + ".");
    }
    
    if(targetDiv && write_out) $("div#" + targetDiv).html("<ol><li>"+output_list.join("</li><li>")+"</li></ol>");
}

// JQuery to load the lists into the page.
$(document).ready(function() {
	var count = 100;

	var trapGenerator = new TrapGenerator(trap.trigger, trap.element, trap.attack);
	trapGenerator.show(count, "traplist", true);

	$("#reload").bind("click",function(){
		trapGenerator.show(count, "traplist", true);
	});
});
</script>

<a name="traps"></a>
<h2>Random Traps (roll 1d100) - <span id="reload">reroll</span></h2>

<div id="traplist"></div>

<h2>How To Use These Traps</h2>

<p>The easiest way to use these traps is to roll 1d100 and pick the appropriate trap set from the list. You can change the flavor of the trap to whatever suits your game. Instead of rolling, you can review the list and use whatever inspires you to add something fun into your game. Because this list is randomly generated, many of the results might seem crazy. You can either ignore them or try to have some fun figuring out how that crazy trap combination would actually work.

<p>Like <a href="http://dicelog.com/yafnag">random name generators</a> or the <a href="http://slyflourish.com/random_mundane_magic_item_generator.html">random mundane magic item generator</a> you should use these traps as inspiration to help you build some awesome detailed traps into your own game. Use it however it fits best into your game and however it makes your life easier as a GM. Roll 1d100 and improvise or scan the list to find one that makes sense for you.

<h2>Re-skin For Your System Of Choice</h2>

<p>This list is intended to work with just about any fantasy RPG. You will want to figure out how best to wrap mechanics around these descriptions, usually as damage and potential effect. Games like <a href="http://rpg.drivethrustuff.com/product/118994/13th-Age-Core-Book?affiliate_id=70406">13th Age</a> and D&D 4th Edition make it easy to wrap mechanics around traps like this. For games like Pathfinder, you'll likely want to wrap mechanics from either a spell or a monster around the result of the generator. In games like Fate including <a href="http://slyflourish.com/dungeons_of_fate.html">Dungeons of Fate</a>, you can use these traps as aspects of a room and challenges to overcome.

<h2>Complicated Combined Traps</h2>

<p>As you clearly noticed, these trap sets actually include two traps combined together. Single traps can often be boring or predictable and easy to overcome. Two traps together builds a more unique mix that's harder for players to get their heads around. You are free, of course, to simplify these traps by picking only one of the two traps rather than both. You can also remove the elemental effects on each trap if they don't make sense or don't fit the game.

<h2>Creative Commons License</h2>

<p>This generator and its content are released under a <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution ShareAlike license</a>. You are free to use these however you wish, including for commercial purposes, as long as you attribute it to <a href="http://slyflourish.com">Sly Flourish</a> (including the hyperlink) and share the results of your work under the same license.